#!/usr/bin/env python3
"""Wraps modules to forward to content or background automatically

"""

import os
import sys

WRAPPER_FILE = '''// AUTOGENERATED FROM {filename} BY auto_lib.py
//
// Automatically forwards invocations to the appropriate context (content
// script, background script, commandline iframe)
//
// DO NOT EDIT

import * as excmd_lib from "@src/lib/excmd_lib"
import * as _excmds from "@{filename_minus_extension}"
export default excmd_lib.forwardedTo{source_cap}("{messagetype}", _excmds)
'''

MESSAGE_NAMES_HEADER = '''// AUTOGENERATED BY auto_lib.py
//
// Autogenerated message names for transparent context-forwarding wrappers
// created by auto_lib.py. Each of these corresponds to the wrapper for a
// single module.
//
// DO NOT EDIT
'''

MESSAGE_NAMES_FILE_PATH = "src/lib/.auto_lib_wrapper_names.generated.ts"

def MangleFilename(source, filename):
    return filename.replace(source + '_lib', 'lib/generated')

def AutoWrapperMessageName(source, filename):
    return "auto_lib_wrapper:{}->{}".format(filename, source)

def Wrap(source, filename):
    output_filename = MangleFilename(source, filename)
    message_name = AutoWrapperMessageName(source, filename)
    if os.path.exists(output_filename):
        with open(output_filename, 'r') as f:
            firstline = f.readline()
            if not firstline.startswith("// AUTOGENERATED"):
                raise ValueError("File {} is not autogenerated and cannot be clobbered".format(output_filename))

    with open(output_filename, 'w') as f:
        wrapper = WRAPPER_FILE.format(
            filename=filename,
            filename_minus_extension=filename[:-3],
            source_cap=source.title(),
            source=source,
            messagetype=message_name,
        )
        f.write(wrapper)
    return message_name

def Traverse(root):
    for root, _, filenames in os.walk(root):
        for filename in filenames:
            if filename.endswith('.ts'):
                yield os.path.join(root, filename)

def AutoLib(source, root):
    for filename in Traverse(root):
        yield Wrap(source, filename)

def WrapperNameToEnumMember(wrapper_name):
    return '    | "{}"'.format(wrapper_name)

def WriteWrapperNamesFile(wrapper_names):
    with open(MESSAGE_NAMES_FILE_PATH, 'w') as f:
        f.write(MESSAGE_NAMES_HEADER)
        f.write("\n")

        for source, message_names in wrapper_names.items():
            f.write("export type AutoLibForwardingTo{} =\n".format(source.title()))
            f.write(WrapperNameToEnumMember("UNUSED_SENTINEL") + "\n")
            for message_name in message_names:
                f.write(WrapperNameToEnumMember(message_name) + "\n")

def EnsureGeneratedDirExistsAndIsEmpty():
    if not os.path.exists("src/lib/generated"):
        os.mkdir("src/lib/generated")
    for existing_file in os.listdir("src/lib/generated"):
        os.remove(os.path.join("src/lib/generated", existing_file))

def main(argv):
    # unused
    del argv

    EnsureGeneratedDirExistsAndIsEmpty()
    wrapper_names = {}
    for source in ['content', 'background', 'commandline']:
        wrapper_names[source] = list(AutoLib(source, os.path.join('src', source + '_lib')))

    WriteWrapperNamesFile(wrapper_names)

if __name__ == "__main__":
    main(sys.argv)
